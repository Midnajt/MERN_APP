JOHN-COURSE {
    SEKCJA 2️⃣: Setup {
        💥 Skrót 'ra' -> snippety do tworzenia komponentów.
        💥 Vite ❤
            - szybsza i łatwiejsza konfiguracja.
            - łatwiejsze podpinanie pluginów.
    }

    SEKCJA 3️⃣: React Router {
        💥 W folderze 'pages' tworzymy komponenty z stronami. Komponenty są importowane i jednocześnie eksportowane z index.js, który jest w tym samym folderze. index.js jest domyślnym entry-pointem, dzięki temu czytelniej i prościej możemy pobierać komponenty z tego folderu np: import { HomeLayout } from "./pages";

        💥 <Link/> z react-router-dom służy do zmieniania route'ów w aplikacji SPA

        💥 <Outlet/> from "react-router-dom"; wyświetla zagnieżdżone routy w rodzicu, w którym użyto tego kopmonentu

        💥 Strona zawierająca atrybut index:true, będzie wyświetlana gdy nasza ścieżka wskazuje na rodzica, przykład:
        const router = createBrowserRouter([
            {
                path: "/",
                element: <HomeLayout />,
                children: [
                    {
                        index: true,
                        element: <Landing />,
                    },
                    {
                        path: "register",
                        element: <Register />,
                    },
                ],
            },
        ]);
    }

    SEKCJA 4️⃣: Landing Page - styled components {
        💥 style css i loika js w jednym pliku komponentu.
        💥 tworzy unikatowe klasy, nie trzeba być oryginalnym i unikatowym przypisując klasę do tagu, chyba że to klasa globalna.
        💥 jeżeli mamy globalną klasę .btn, to możemy do niej dodawać parametry w styled components danego kopmonentu.
        💥 import styled from "styled-components";
           const Wrapper = styled.div`<style css>`;
            function Landing() {
                return (
                    <Wrapper>
                        <h1>Landing</h1>
                    </Wrapper>
                );
            }
    }

    SEKCJA 5️⃣: Error Page {💥 }
    SEKCJA 6️⃣: Register Page {💥 }
    SEKCJA 7️⃣: Login Page {💥 }
    SEKCJA 8️⃣: Dashboard Page {
        💥 hook useContext służy do zarządzania zmiennymi oraz funkcjami globalnymi, które mają wpływ na wygląd aplikacji
            - import { createContext} from "react";
            - tworzymy const DashboardContext = createContext(); przed zdefiniowaniem komponentu
            - jako nadrzędny komponent ustawiamy:
             <DashboardContext.Provider value={{ , toggleSidebar, logOutUser, isDarkTheme, toggleDarkTheme}}><DashboardContext.Provider/>
            - w value mamy funkcje i staty
            - exportujemy context, aby można było korzystać z niego w innych miejscach:
                export const useDashboardContext = () => useContext(DashboardContext);
            - import w innym komponencie:
            import { useDashboardContext } from "../pages/DashboardLayout";
            - zdefiniowanie funkcji w komponencie pobranej z contextu:
            const { toggleSidebar } = useDashboardContext();

        💥 checkDefaultTheme z App.jsx sprawdza czy jest ciasteczko z dark/light mode i zwraca bool.
        💥 komponent DashboardLayout wywołuje tę funkcję żeby sprawdzić jaką ikonkę ma wyświetlić (słońce/księżyc)
        💥 kliknięcie słońce/księżyc zmienia ciasteczko oraz ustawić odpowiednie atrybuty w document.body
    }
    SEKCJA 9️⃣: Server {
        💥 pamiętaj o '.js' w importowaniu danych z plików w module node.js.
        💥 test-default.js {export default someValue;} -> import randomValue from "./test-default.js"; pobieramy defaultową wartość i nazywamy ją jak chcemy.
        💥 test-named.js {export const value = 42;} -> import { value } from "./test-named.js"; pobieramy konkretną wartość z danego pliku.

        💥 Express - minimalistyczny framework do node, wykorzystywany przy obsłudze requestów HTTP oraz tworzenia SPA API
        💥 Nodemon - poprawia pracę developera, monitoruje kod node'a i restartuje gdy nadarzy się taka potrzeba (np podczas pracy nad aplikacją i modyfikowaniu kodu).
        💥 Thunder Client - rozszerzenie do VSC, które zapeniwa narzędzia do testowania i debugowania serwera, http requestów, badania headerów, wyświetlania JSON/XML podczas tworzenia aplikacji.
        💥 Morgan - tworzy logi do middleware requestow
        💥 Dotenv - obsługuje zmienne środowiskowe
        💥 używać fetch w node express, można dopiero od wersji node 18 (2022r). Wcześniej trzeba było robić fikołki. Przykład fetcha:
            fetch("https://www.course-api.com/react-useReducer-cart-project")
                .then((res) => res.json())
                .then((data) => console.log(data));
        💥 Nanoid generuje URL z krótki id na długie 64 symbolowe znaki
        💥 ustawienie statusu na 404 na wszystkie routy, które nie zostały zdefiniowane w app
            app.use("*", (req, res) => {
                res.status(404).json({ msg: "not found" });
            });
        💥 obsługa błędów w app, jest trigerowany na poziomie route/serwera (np wywoła zmienną, która nie jest zdefiniowana)
            app.use((err, req, res, next) => {
                console.log(err);
                res.status(500).json({ msg: "something went wrong" });
            });
    }
}


HTTP STATUS {
    200: sukces (GET),
    201: sukces (PUT),
    404: porażka (PUT) z wiadomością do wyświetlenia użytkownikowi
}







***
    .map(() => {})
        - nawiasy klamrowe przekazują pełne ciało funkcji co oznacza że nalezy użyć słowa kluczowego 'return'
    .map(() => ())
        - skrócona funkcja strzałkowa
        wynik po '=>' jest automatycznie zwracany, tak jakby tam było 'return'.



🛠 skrót 'ra' -> snippety do tworzenia komponentów
🛠 *Skup się na obsłudze css oraz tagów <img/>
🛠 Zrób/znajdź ściągawkę do headersów w http requestach.
🛠 Naucz się narzędzia do tworzenia projektów aplikacji/frontendu/stron www (skatch app, figma?).
🛠 Framer naucz się go porządnie.

MAX-COURse {
    SEKCJA 1️⃣ {

        💥MERN = {
            MongoDB,
            Express,
            React,
            Node
        }

        client (browser) wysyła request do servera <=> serwer zwraca response do clienta
    }
    SEKCJA 2️⃣ {

        💥Backend:
            ◽ REST API (Representational State Transfer), poplarniejsze.
                - ścieżki url z żądaniami HTTP z GET, POST, PATCH, DELETE.  wszystko jest traktowane jako zasób (np. użytkownicy, zdjęcia, artykuły). Każdy zasób ma unikalny URI (Uniform Resource Identifier). GET: Pobiera zasób. POST: Tworzy nowy zasób. PUT: Aktualizuje istniejący zasób. DELETE: Usuwa zasób.
                - endpointy trigerujące różne akcje.
            ◽ GraphQL API
                - jeden URL, zwykle POST, zawiera query.
                - używa query expression zamiast HTTP request.
                - wymaga nauczenia się jeżyka do tworzenia query.

            Oba podejścia egzekwują kod po stronie serwera.

        💥Dwa sposoby łączenia Node z react:
            ◽ Serwer przetrzymuje Node API + React SPA na jednej domenie.
                - requesty które nie targetują API routes zwracają React SPA.
            ◽ Jeden serwer do Frontendu, drugi do Backend Api.
                - Nodex/Express przyjmuje requesty.
                - React SPA na drugim serwerze.

            ◽ Niezależnie od wyboru, frontend zawsze łączy się w ten sam sposób z backendem

            *Trzeci sposób: Server-side rendered Pages (SRP)
            ◽ Komponenty generowane przez serwer.

        💥 ZAPAMIĘTAJ

            ➡ Zwraca json
            app.get('/products', (req, res, next) => {
                res.status(200).json({ products: DUMMY_PRODUCTS });
            });

            ⬅Odbiera json
            useEffect(() => {
                const fetchProducts = async () => {
                    setIsLoading(true);
                    const response = await fetch('http://przykladowe_url/products');

                    const responseData = await response.json();

                    setLoadedProducts(responseData.products);
                    setIsLoading(false);
                };

                fetchProducts();
            }, []);
    }
    SEKCJA 3️⃣ {

        💥 Planowanie
            1. Pomysł na aplikację lub problem, który można rozwiązać aplikacją.
                - Aplikacja do udostępniania odwiedzonych miejsc wraz z obrazami i opisem.
                - Inni użytkownicy mogą przeglądać miejsca odwiedzone przez danego/klikniętego użytkownika.
            2. Stworzenie projektu.
                - CRUD
            3. Rozplanuj obsługę danych, które będa obsługiwane.
                - Wczytywanie obrazów oraz walidacja danych.
                - Różne widoki.
                - Autoryzacja.
            4. Zaplanuj endpointy i strony lub komponenty.
    }
    SEKCJA 4️⃣ {
        💥 React - odświeżenei
        💥 Czym jest React
            - biblioteka js, która służy do tworzenia interfejsów użytkownika, która pracuje po stronie klienta.
            - pseudo-framework, po dodaniu rozwiązań takich jak redux, routing React niemal staje się frameworkiem.
            - podejście deklaratywne, definiujemy wynik, a nie jak ma do niego dojść. W vanilla js musielibyśmy wszystko oprogramować.
            - w projekcie zarządzami komponentami, które renderują odpowiednie treści w danym momencie.
            - React wykorzystywany jest przedewszystkim do tworzenia SPA - Single Page Aplication.

        ✔ O co chodzi w React? Renderowanie i aktualizowanie interfejsu, obsługa zachowań użytkownika.
        ✔ Co to są props? Dane przekazywane z komponentu rodzica to dzieci.
        ✔ Czym są komponenty? Funkcje js zwracające składnie JSX, stanowiącą bloki elementów w projekcie.
        ✔ Co to jest state? To zmienne które możesz zmieniać wewnątrząc komponentu, wywoła go je ponowne renderowanie.
        ✔ Co to jest hook? Specjalne funkcje obsługujące różne wydarzenia w komponencie, którą pozwalają dodawać wiele opcji wewnątrz komponentu.

        💥 Two-way-binding
            - łączenie inputu z state'em, value input to state, onChange uruchamiane jest setState.
    }

    SEKCJA 5️⃣ {
        Tworzenie Frontendu

        💥 react-router-dom -> obsługuje routing, tworzenie url i zachowanie aplikacji na tej podstawie

    }
}

bcp{
    In such cases it will help to replace (in package.json) ...

    "start": "react-scripts start"
    ... with ...

    "start": "react-scripts --openssl-legacy-provider start"
    ... and ...

    "build": "react-scripts build"
    ... with ...

    "build": "react-scripts --openssl-legacy-provider build"
}